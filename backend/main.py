# backend/main.py
import asyncio
import sys
import os
from typing import Dict, List
from fastapi import FastAPI
from pydantic import BaseModel
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from dotenv import load_dotenv
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail
import requests

# Ensure agents folder is importable
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Import agents
from my_agents.discovery_agent import find_companies
from my_agents.deep_dive_agent import run_concurrent_deep_dive

# Load environment variables
load_dotenv()

# Azure OpenAI config (optional)
AZURE_KEY = os.getenv("AZURE_OPENAI_KEY")
AZURE_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_DEPLOYMENT = os.getenv("AZURE_OPENAI_GPT_DEPLOYMENT_NAME")

# SendGrid config
SENDGRID_KEY = os.getenv("SENDGRID_API_KEY")
REPORT_FROM_EMAIL = os.getenv("REPORT_FROM_EMAIL")

# Optional OpenAI import
try:
    from openai import AzureOpenAI
except ImportError:
    openai = None

app = FastAPI(title="Investment Sourcing Agent - Backend")

# Allow frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*", "http://localhost:8502"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# -------------------------
# Email helpers
# -------------------------
def build_email_content(criteria: str, attributes: List[str], results: List[Dict]) -> str:
    html = f"<h2>Investment Scout Report</h2>"
    html += f"<p><strong>Search Criteria:</strong> {criteria}</p>"
    html += "<table border='1' cellpadding='5' cellspacing='0'>"
    html += "<tr>" + "".join([f"<th>{attr}</th>" for attr in attributes]) + "</tr>"
    for startup in results:
        html += "<tr>" + "".join([f"<td>{startup.get(attr, '-')}</td>" for attr in attributes]) + "</tr>"
    html += "</table>"
    html += "<p>Generated by Investment Sourcing Agent</p>"
    return html

def send_email_report(to_email: str, subject: str, html_content: str):
    message = Mail(
        from_email=REPORT_FROM_EMAIL,
        to_emails=to_email,
        subject=subject,
        html_content=html_content
    )
    try:
        sg = SendGridAPIClient(SENDGRID_KEY)
        response = sg.send(message)
        return response.status_code, response.body
    except Exception as e:
        return None, str(e)

# -------------------------
# Simple query enhancer
# -------------------------
def _generate_keywords(text: str):
    words = [w.strip(".,()") for w in text.split() if len(w) > 2]
    keywords = set(words[:6])
    syn_map = {
        "infra": ["infrastructure", "platform", "stack"],
        "crypto": ["blockchain", "web3", "cryptocurrency"],
        "healthcare": ["health tech", "medtech", "digital health"],
        "ai": ["artificial intelligence", "machine learning", "ml"]
    }
    for w in words:
        lw = w.lower()
        if lw in syn_map:
            keywords.update(syn_map[lw])
    return list(keywords)[:12]

def _build_refined_query(text: str) -> str:
    return f"{text.strip()} | Add nearby synonyms, include funding stage, location, and technology tags."

def _simple_enhance(text: str) -> str:
    if not text.strip():
        return "Please provide search criteria to enhance."
    enhancements = [
        f"- Original: {text.strip()}",
        "- Expanded keywords: " + ", ".join(_generate_keywords(text)),
        "- Suggested filters: Seed/Series A, Region: specify country/city, Industry verticals",
        "- Suggested exclusions: (e.g., exclude non-tech, exclude pre-seed)",
        "",
        "Refined search query (suggested): " + _build_refined_query(text)
    ]
    return "\n".join(enhancements)

# -------------------------
# Enhance endpoint
# -------------------------
class EnhanceRequest(BaseModel):
    user_query: str

@app.post("/enhance_query")
async def enhance_query(payload: EnhanceRequest) -> Dict[str, str]:
    text = payload.user_query or ""
    if openai and AZURE_KEY and AZURE_ENDPOINT and AZURE_DEPLOYMENT:
        try:
            openai.api_type = "azure"
            openai.api_key = AZURE_KEY
            openai.api_base = AZURE_ENDPOINT

            client = AzureOpenAI(
                azure_endpoint=AZURE_ENDPOINT,
                api_key=AZURE_KEY,
                api_version="2024-02-01"
            )
            
            response = client.chat.completions.create(
                model=AZURE_DEPLOYMENT,
                messages=[
                    {"role": "system", "content": "You are an assistant that refines investment search queries."},
                    {"role": "user", "content": f"Refine and expand this search criteria: {text}"}
                ],
                max_tokens=300
            )
            refined = response.choices[0].message["content"].strip()
            return {"refined_query": refined}
        except Exception:
            refined = _simple_enhance(text)
            return {"refined_query": refined}
    refined = _simple_enhance(text)
    return {"refined_query": refined}

# -------------------------
# Linkup API Search endpoint
# -------------------------
class LinkupSearchRequest(BaseModel):
    search_criteria: str
    location: str = None
    funding_stage: str = None

@app.post("/linkup_search")
async def linkup_search(payload: LinkupSearchRequest) -> Dict:
    """
    Search for companies using Linkup API.
    
    Args:
        payload: Contains search_criteria, optional location, and optional funding_stage
    
    Returns:
        Dict with success status and results list
    """
    LINKUP_API_KEY = os.getenv("LINKUP_API_KEY")
    
    if not LINKUP_API_KEY:
        return {
            "success": False,
            "error": "LINKUP_API_KEY not configured",
            "results": []
        }
    
    try:
        # Build Linkup API request
        linkup_url = "https://api.linkup.so/v2/job_search"
        
        headers = {
            "Authorization": f"Bearer {LINKUP_API_KEY}",
            "Content-Type": "application/json"
        }
        
        # Construct search query with filters
        query = payload.search_criteria
        if payload.location:
            query += f" location:{payload.location}"
        if payload.funding_stage:
            query += f" funding_stage:{payload.funding_stage}"
        
        linkup_payload = {
            "query": query,
            "limit": 20
        }
        
        # Make request to Linkup API
        response = requests.post(linkup_url, json=linkup_payload, headers=headers, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            return {
                "success": True,
                "results": data.get("jobs", [])
            }
        else:
            return {
                "success": False,
                "error": f"Linkup API returned status {response.status_code}",
                "results": []
            }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "results": []
        }

# -------------------------
# SSE agent generator
# -------------------------
async def run_agent_and_stream(criteria: str, attributes: List[str], email: str):
    yield "event: status\ndata: Setting up agent environment...\n\n"
    await asyncio.sleep(1)

    yield f"event: status\ndata: ğŸ” Running Discovery Agent with criteria: {criteria}\n\n"
    await asyncio.sleep(1)

    # -------------------------
    # Discovery Agent
    # -------------------------
    results = find_companies(criteria=criteria)
    if not results:
        yield "event: status\ndata: âš ï¸ No companies found.\n\n"
        results = []
    else:
        yield f"event: status\ndata: âœ… Found {len(results)} companies.\n\n"
        await asyncio.sleep(1)

    # -------------------------
    # Deep Dive Agent
    # -------------------------
    if results:
        deep_results = await run_concurrent_deep_dive(results, criteria, attributes)
        results = deep_results  # replace raw results with enriched results
        for idx, company in enumerate(results, start=1):
            yield f"event: status\ndata: âš™ï¸ Analyzing startup {idx} of {len(results)}: {company.get('Company Name', 'N/A')}\n\n"
            await asyncio.sleep(1)

    # -------------------------
    # Send Email
    # -------------------------
    yield "event: status\ndata: ğŸ“§ Generating final report and preparing email...\n\n"
    await asyncio.sleep(1)

    email_html = build_email_content(criteria, attributes, results)
    status_code, response_body = send_email_report(email, "Investment Scout Report", email_html)

    if status_code:
        yield f"event: status\ndata: ğŸ“¬ Report successfully sent to {email}!\n\n"
    else:
        yield f"event: status\ndata: âŒ Failed to send email: {response_body}\n\n"

    yield "event: complete\ndata: {\"success\": true}\n\n"

# -------------------------
# SSE endpoint
# -------------------------
class ScoutRequest(BaseModel):
    search_criteria: str
    attributes: List[str]
    email: str

@app.post("/run_scout")
async def run_scout(payload: ScoutRequest):
    return StreamingResponse(
        run_agent_and_stream(
            criteria=payload.search_criteria,
            attributes=payload.attributes,
            email=payload.email
        ),
        media_type="text/event-stream"
    )
